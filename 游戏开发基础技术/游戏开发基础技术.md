

## Interface 接口
Interface（接口） 是实现解耦通信、跨类型调用、蓝图与 C++ 协作 的核心机制之一。尤其在开发如 交互系统（Interaction System） 这类需要“不同对象响应同一操作”（如开门、拾取、对话）的场景中，接口几乎是最优解。

>为什么需要 Interface？
**问题场景**
你有一个玩家角色，按下 E 键 想与面前物体互动：
如果是 门 → 执行 Open()
如果是 宝箱 → 执行 Loot()
如果是 NPC → 执行 Talk()
**传统方案**：
LineTrace → HitActor
→ Cast to Door? → Open
→ Cast to Chest? → Loot
→ Cast to NPC? → Talk
❌ **缺点**：
硬编码耦合：每新增一种可交互物，就要加一个 Cast。
性能差：多次失败的 Cast 浪费 CPU。
不可扩展：无法支持 Mod 或动态加载内容。

✅ **接口方案**：
所有可交互对象都实现 IInteractable 接口，提供 Interact() 方法。
玩家无需知道具体类型：
LineTrace → HitActor
→ Does Implement Interface IInteractable?
→ Yes → Call Interact(Target = HitActor)

```cpp
// 蓝图可覆盖 + C++ 可实现
UFUNCTION(BlueprintNativeEvent, BlueprintCallable, Category = "Interaction")
void Interact(AActor* Instigator);

// 纯 C++ 虚函数（蓝图不可见）
virtual void OnInteractBegin() {}
```
⚠️ 注意：
BlueprintNativeEvent 声明时不能写 virtual
实现时需加 _Implementation 后缀

**实现接口（C++ 类）**
```cpp
// Door.h
#include "InteractableInterface.h"

UCLASS()
class ADoor : public AActor, public IInteractable
{
    GENERATED_BODY()

public:
    // 实现接口函数
    virtual void Interact_Implementation(AActor* Instigator) override;
};
--------------------------
// Door.cpp
void ADoor::Interact_Implementation(AActor* Instigator)
{
    UE_LOG(LogTemp, Warning, TEXT("Door opened by %s"), *Instigator->GetName());
    // 执行开门动画、音效等
}
```
✅ 关键点：
类需同时继承 AActor（或其他 UObject 子类）和 IInteractable
函数名必须为 原始名_Implementation

检查接口实现的时候使用Implements<>()函数：
```cpp
if (OtherActor->Implements<UMP_Player>())
```
🔔 注意：
检查用 U 类（UMP_Player）
调用用 I 类（IMP_Player::Execute_...）
> Implements<T>() 是 UObject 的模板函数, 只有 U 类（继承自 UObject）才有 StaticClass() 函数, 所以检查接口实现时必须用 U 类。



